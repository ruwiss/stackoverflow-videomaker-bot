<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Video Oluşturucu - <%= question.title %></title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet" />
    <style>
      .video-preview {
        background: #000;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }

      .control-panel {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 15px;
        padding: 25px;
        color: white;
      }

      .step-indicator {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 15px;
      }

      .progress-ring {
        transform: rotate(-90deg);
      }

      .progress-ring-background {
        fill: none;
        stroke: rgba(255, 255, 255, 0.2);
        stroke-width: 4;
      }

      .progress-ring-fill {
        fill: none;
        stroke: #28a745;
        stroke-width: 4;
        stroke-linecap: round;
        transition: stroke-dashoffset 0.5s ease;
      }

      .btn-create-video {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: none;
        padding: 15px 30px;
        border-radius: 25px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        transition: all 0.3s ease;
      }

      .btn-create-video:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
      }

      #videoCanvas {
        width: 100%;
        height: auto;
        max-height: 400px;
        border: 2px solid #dee2e6;
        border-radius: 10px;
        aspect-ratio: 16/9;
        object-fit: contain;
      }

      .video-stats {
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 15px;
        border-radius: 5px;
        position: absolute;
        top: 10px;
        left: 10px;
        font-family: "Courier New", monospace;
        font-size: 12px;
      }

      .timeline {
        background: #f8f9fa;
        border-radius: 10px;
        padding: 20px;
        margin-top: 20px;
      }

      .timeline-step {
        display: flex;
        align-items: center;
        padding: 10px;
        margin: 5px 0;
        background: white;
        border-radius: 8px;
        border-left: 4px solid #6c757d;
        transition: all 0.3s ease;
      }

      .timeline-step.active {
        border-left-color: #28a745;
        background: #f8fff9;
      }

      .timeline-step.completed {
        border-left-color: #007bff;
        background: #f0f8ff;
      }
    </style>
  </head>
  <body class="bg-light">
    <div class="container-fluid py-4">
      <div class="row">
        <!-- Sol Panel - Video Önizleme -->
        <div class="col-lg-8">
          <div class="card shadow-sm">
            <div class="card-header bg-dark text-white">
              <h5 class="mb-0"><i class="fas fa-video me-2"></i>Video Önizleme - 1920x1080</h5>
            </div>
            <div class="card-body p-0 position-relative">
              <canvas id="videoCanvas" width="1920" height="1080"></canvas>
              <div class="video-stats" id="videoStats">Adım: 0/0 | Süre: 00:00 | FPS: 30</div>
            </div>
          </div>

          <!-- Timeline -->
          <div class="timeline">
            <h6><i class="fas fa-timeline me-2"></i>Adım Timeline</h6>
            <div id="timelineContainer">
              <!-- Timeline steps will be inserted here -->
            </div>
          </div>
        </div>

        <!-- Sağ Panel - Kontroller -->
        <div class="col-lg-4">
          <div class="control-panel">
            <h5 class="text-center mb-4"><i class="fas fa-cogs me-2"></i>Video Kontrolü</h5>

            <!-- Progress Ring -->
            <div class="text-center mb-4">
              <svg width="120" height="120" class="progress-ring">
                <circle class="progress-ring-background" cx="60" cy="60" r="54"></circle>
                <circle class="progress-ring-fill" cx="60" cy="60" r="54" stroke-dasharray="339.292" stroke-dashoffset="339.292" id="progressRing"></circle>
              </svg>
              <div class="mt-2">
                <strong id="progressText">0%</strong>
                <br />
                <small id="progressSubtext">Hazırlanıyor</small>
              </div>
            </div>

            <!-- Video Bilgileri -->
            <div class="step-indicator">
              <h6><i class="fas fa-info-circle me-2"></i>Video Bilgileri</h6>
              <p class="mb-1"><strong>Başlık:</strong> <%= videoData.title %></p>
              <p class="mb-1"><strong>Toplam Adım:</strong> <%= videoData.steps.length %></p>
              <p class="mb-1"><strong>Tahmini Süre:</strong> <%= videoData.estimatedDurationFormatted %></p>
              <p class="mb-0"><strong>Çözünürlük:</strong> 1920x1080 (Full HD)</p>
            </div>

            <!-- Mevcut Adım -->
            <div class="step-indicator">
              <h6><i class="fas fa-play-circle me-2"></i>Mevcut Adım</h6>
              <p class="mb-1" id="currentStepInfo">Başlamadı</p>
              <div class="progress mt-2">
                <div class="progress-bar bg-success" role="progressbar" style="width: 0%" id="stepProgress"></div>
              </div>
            </div>

            <!-- Kontrol Butonları -->
            <div class="text-center mt-4">
              <button class="btn btn-create-video btn-lg w-100 mb-3" id="startVideoBtn"><i class="fas fa-play me-2"></i>Video Oluşturmaya Başla</button>

              <button class="btn btn-outline-light w-100 mb-2" id="previewBtn"><i class="fas fa-eye me-2"></i>Önizleme</button>

              <button class="btn btn-outline-light w-100" id="downloadBtn" style="display: none"><i class="fas fa-download me-2"></i>Video İndir</button>
            </div>

            <!-- Video Ayarları -->
            <div class="step-indicator mt-4">
              <h6><i class="fas fa-cog me-2"></i>Video Ayarları</h6>

              <div class="mb-3">
                <label class="form-label">Tema:</label>
                <div class="d-flex gap-2">
                  <button class="btn btn-outline-light btn-sm flex-grow-1" id="currentThemeBtn"><i class="fas fa-palette me-2"></i><span id="currentThemeName">Mor Galaksi</span></button>
                  <button class="btn btn-outline-warning btn-sm" id="randomThemeBtn" title="Rastgele Tema">
                    <i class="fas fa-random"></i>
                  </button>
                </div>
                <small class="text-light">Videoda kullanılacak renk teması</small>
              </div>

              <div class="mb-3">
                <label class="form-label">FPS:</label>
                <select class="form-select" id="fpsSelect">
                  <option value="24">24 FPS (Sinema)</option>
                  <option value="30" selected>30 FPS (Standard)</option>
                  <option value="60">60 FPS (Smooth)</option>
                </select>
              </div>

              <div class="mb-3">
                <label class="form-label">Kalite:</label>
                <select class="form-select" id="qualitySelect">
                  <option value="high" selected>Yüksek Kalite</option>
                  <option value="medium">Orta Kalite</option>
                  <option value="low">Düşük Kalite</option>
                </select>
              </div>

              <div class="form-check mb-3">
                <input class="form-check-input" type="checkbox" id="includeAudio" checked />
                <label class="form-check-label" for="includeAudio"> Ses Dahil Et </label>
              </div>

              <div class="form-check mb-3">
                <input class="form-check-input" type="checkbox" id="includeBackgroundMusic" checked />
                <label class="form-check-label" for="includeBackgroundMusic"> Arkaplan Müziği </label>
              </div>

              <div class="mb-3" id="musicVolumeContainer">
                <label class="form-label">Müzik Ses Seviyesi:</label>
                <input type="range" class="form-range" id="musicVolume" min="0" max="100" value="2" />
                <small class="text-light">%<span id="musicVolumeValue">2</span></small>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      // Video data from server
      const videoData = <%- JSON.stringify(videoData) %>;
      const questionId = '<%= question.id %>';

      console.log('Video Data:', videoData);

      // Canvas and context
      const canvas = document.getElementById('videoCanvas');
      const ctx = canvas.getContext('2d');

      // Video settings
      let fps = 30;
      let quality = 'high';
      let includeAudio = true;
      let includeBackgroundMusic = true;
      let musicVolume = 0.02;
      let backgroundMusic = null;
      let backgroundMusicGain = null;

      // Tema sistemi
      let currentTheme = 0;
      const videoThemes = [
        {
          name: 'Mor Galaksi',
          background: ['#0F0F23', '#1e1e3f', '#2d1b69'],
          primary: '#7C3AED',
          secondary: '#A855F7',
          accent: '#C084FC',
          particle: 'rgba(124, 58, 237, 0.1)',
          glow: '#7C3AED',
          textShadow: 'rgba(124, 58, 237, 0.5)'
        },
        {
          name: 'Gece Mavisi',
          background: ['#0B1426', '#1E3A8A', '#1E40AF'],
          primary: '#3B82F6',
          secondary: '#60A5FA',
          accent: '#93C5FD',
          particle: 'rgba(59, 130, 246, 0.1)',
          glow: '#3B82F6',
          textShadow: 'rgba(59, 130, 246, 0.5)'
        },
        {
          name: 'Karanlık Yeşil',
          background: ['#0F1419', '#064E3B', '#065F46'],
          primary: '#10B981',
          secondary: '#34D399',
          accent: '#6EE7B7',
          particle: 'rgba(16, 185, 129, 0.1)',
          glow: '#10B981',
          textShadow: 'rgba(16, 185, 129, 0.5)'
        },
        {
          name: 'Turuncu Alev',
          background: ['#1C1917', '#7C2D12', '#9A3412'],
          primary: '#F97316',
          secondary: '#FB923C',
          accent: '#FDBA74',
          particle: 'rgba(249, 115, 22, 0.1)',
          glow: '#F97316',
          textShadow: 'rgba(249, 115, 22, 0.5)'
        },
        {
          name: 'Pembe Neon',
          background: ['#18181B', '#7C2D92', '#A21CAF'],
          primary: '#E11D48',
          secondary: '#F43F5E',
          accent: '#FB7185',
          particle: 'rgba(225, 29, 72, 0.1)',
          glow: '#E11D48',
          textShadow: 'rgba(225, 29, 72, 0.5)'
        },
        {
          name: 'Sarı Elektrik',
          background: ['#1C1917', '#92400E', '#B45309'],
          primary: '#F59E0B',
          secondary: '#FBBF24',
          accent: '#FCD34D',
          particle: 'rgba(245, 158, 11, 0.1)',
          glow: '#F59E0B',
          textShadow: 'rgba(245, 158, 11, 0.5)'
        },
        {
          name: 'Kırmızı Matrix',
          background: ['#0F0F0F', '#7F1D1D', '#991B1B'],
          primary: '#DC2626',
          secondary: '#EF4444',
          accent: '#F87171',
          particle: 'rgba(220, 38, 38, 0.1)',
          glow: '#DC2626',
          textShadow: 'rgba(220, 38, 38, 0.5)'
        },
        {
          name: 'Turkuaz Okyanus',
          background: ['#0F1419', '#155E75', '#0E7490'],
          primary: '#0891B2',
          secondary: '#22D3EE',
          accent: '#67E8F9',
          particle: 'rgba(8, 145, 178, 0.1)',
          glow: '#0891B2',
          textShadow: 'rgba(8, 145, 178, 0.5)'
        },
        {
          name: 'Soft Lavanta',
          background: ['#1A1A2E', '#2D2D4A', '#3E3E66'],
          primary: '#8B7CF6',
          secondary: '#A78BFA',
          accent: '#C4B5FD',
          particle: 'rgba(139, 124, 246, 0.1)',
          glow: '#8B7CF6',
          textShadow: 'rgba(139, 124, 246, 0.5)'
        },
        {
          name: 'Yumuşak Mavi',
          background: ['#1E2A3A', '#2C4663', '#3A5A7C'],
          primary: '#60A5FA',
          secondary: '#93C5FD',
          accent: '#BFDBFE',
          particle: 'rgba(96, 165, 250, 0.1)',
          glow: '#60A5FA',
          textShadow: 'rgba(96, 165, 250, 0.5)'
        },
        {
          name: 'Pastel Yeşil',
          background: ['#1A2E2A', '#2D4B3F', '#406854'],
          primary: '#4ADE80',
          secondary: '#86EFAC',
          accent: '#BBF7D0',
          particle: 'rgba(74, 222, 128, 0.1)',
          glow: '#4ADE80',
          textShadow: 'rgba(74, 222, 128, 0.5)'
        },
        {
          name: 'Soft Coral',
          background: ['#2A1E1E', '#4B3535', '#6B4C4C'],
          primary: '#FB7185',
          secondary: '#FDA4AF',
          accent: '#FECACA',
          particle: 'rgba(251, 113, 133, 0.1)',
          glow: '#FB7185',
          textShadow: 'rgba(251, 113, 133, 0.5)'
        },
        {
          name: 'Warm Amber',
          background: ['#2A2416', '#4B4020', '#6B5B2A'],
          primary: '#FBBF24',
          secondary: '#FCD34D',
          accent: '#FEF3C7',
          particle: 'rgba(251, 191, 36, 0.1)',
          glow: '#FBBF24',
          textShadow: 'rgba(251, 191, 36, 0.5)'
        },
        {
          name: 'Soft Cyan',
          background: ['#1A2A2E', '#2D4B54', '#40686B'],
          primary: '#22D3EE',
          secondary: '#67E8F9',
          accent: '#A5F3FC',
          particle: 'rgba(34, 211, 238, 0.1)',
          glow: '#22D3EE',
          textShadow: 'rgba(34, 211, 238, 0.5)'
        },
        {
          name: 'Gentle Rose',
          background: ['#2E1A2A', '#4B2D42', '#68405A'],
          primary: '#F472B6',
          secondary: '#F9A8D4',
          accent: '#FBCFE8',
          particle: 'rgba(244, 114, 182, 0.1)',
          glow: '#F472B6',
          textShadow: 'rgba(244, 114, 182, 0.5)'
        },
        {
          name: 'Mist Gray',
          background: ['#1F1F23', '#3A3A42', '#555561'],
          primary: '#9CA3AF',
          secondary: '#D1D5DB',
          accent: '#E5E7EB',
          particle: 'rgba(156, 163, 175, 0.1)',
          glow: '#9CA3AF',
          textShadow: 'rgba(156, 163, 175, 0.5)'
        },
        {
          name: 'Soft Indigo',
          background: ['#1E1E2E', '#323244', '#46465A'],
          primary: '#818CF8',
          secondary: '#A5B4FC',
          accent: '#C7D2FE',
          particle: 'rgba(129, 140, 248, 0.1)',
          glow: '#818CF8',
          textShadow: 'rgba(129, 140, 248, 0.5)'
        }
      ];

      function getCurrentTheme() {
        return videoThemes[currentTheme];
      }

      function changeTheme(themeIndex = null) {
        if (themeIndex !== null) {
          currentTheme = themeIndex;
        } else {
          // Random tema seç
          currentTheme = Math.floor(Math.random() * videoThemes.length);
        }

        const theme = getCurrentTheme();
        document.getElementById('currentThemeName').textContent = theme.name;

        // Eğer welcome screen gösteriliyorsa yeniden çiz
        if (!isRecording && !previewMode) {
          drawWelcomeScreen();
        }

        console.log('Tema değiştirildi:', theme.name);
      }

      // Video state
      let isRecording = false;
      let mediaRecorder = null;
      let recordedChunks = [];
      let currentStepIndex = 0;
      let currentStepTime = 0;
      let animationId = null;
      let startTime = null;
      let audioContext = null;
      let audioDestination = null;
      let currentAudio = null;
      let adjustedStepDurations = {};
      let isTransitioning = false;
      let transitionTime = 0;
      let currentTransitionDuration = 2; // Dinamik geçiş süresi
      let audioDurationsLoaded = false;
      let previewMode = false;

      // UI Elements
      const startBtn = document.getElementById('startVideoBtn');
      const previewBtn = document.getElementById('previewBtn');
      const downloadBtn = document.getElementById('downloadBtn');
      const progressRing = document.getElementById('progressRing');
      const progressText = document.getElementById('progressText');
      const progressSubtext = document.getElementById('progressSubtext');
      const currentStepInfo = document.getElementById('currentStepInfo');
      const stepProgress = document.getElementById('stepProgress');
      const videoStats = document.getElementById('videoStats');
      const timelineContainer = document.getElementById('timelineContainer');

      // Initialize
      initializeCanvas();
      createTimeline();
      setupEventListeners();
      preloadAudioDurations();
      preloadImages();

      function initializeCanvas() {
        // Set canvas background
        ctx.fillStyle = '#0F0F23';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Start welcome screen animation
        animateWelcomeScreen();
      }

      function animateWelcomeScreen() {
        if (!isRecording && !previewMode) {
          drawWelcomeScreen();
          requestAnimationFrame(animateWelcomeScreen);
        }
      }

      function drawWelcomeScreen() {
        const theme = getCurrentTheme();

        // Clear canvas
        ctx.fillStyle = theme.background[0];
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Modern gradient background - tema renklerini kullan
        const gradient = ctx.createRadialGradient(
          canvas.width/2, canvas.height/2, 0,
          canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/2
        );
        gradient.addColorStop(0, theme.background[1]);
        gradient.addColorStop(0.5, theme.background[2]);
        gradient.addColorStop(1, theme.background[0]);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Add animated particles - tema renginde
        const time = Date.now() * 0.001;
        ctx.fillStyle = theme.particle;
        for (let i = 0; i < 20; i++) {
          const x = (Math.sin(time + i) * 200) + canvas.width / 2;
          const y = (Math.cos(time + i * 0.5) * 100) + canvas.height / 2;
          const size = Math.sin(time + i) * 2 + 3;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }

        // Modern title container
        const titleContainer = {
          x: canvas.width * 0.1,
          y: canvas.height * 0.3,
          width: canvas.width * 0.8,
          height: canvas.height * 0.4
        };

        // Glass morphism background
        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.fillRect(titleContainer.x, titleContainer.y, titleContainer.width, titleContainer.height);

        // Border glow - tema renginde
        ctx.strokeStyle = theme.primary + '80'; // 50% opacity
        ctx.lineWidth = 2;
        ctx.strokeRect(titleContainer.x, titleContainer.y, titleContainer.width, titleContainer.height);

        // Title text
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 72px system-ui, -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const title = videoData.title || 'Video Başlığı';
        const maxWidth = titleContainer.width - 100;
        const words = title.split(' ');
        let lines = [];
        let currentLine = '';

        for (const word of words) {
          const testLine = currentLine + (currentLine ? ' ' : '') + word;
          const metrics = ctx.measureText(testLine);

          if (metrics.width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = testLine;
          }
        }
        if (currentLine) lines.push(currentLine);

        // Draw title with glow effect - tema renginde
        const lineHeight = 90;
        const titleY = titleContainer.y + titleContainer.height/2 - ((lines.length - 1) * lineHeight / 2);

        lines.forEach((line, index) => {
          const y = titleY + index * lineHeight;

          // Glow effect - tema renginde
          ctx.shadowColor = theme.glow;
          ctx.shadowBlur = 20;
          ctx.fillStyle = '#FFFFFF';
          ctx.fillText(line, canvas.width / 2, y);

          // Reset shadow
          ctx.shadowBlur = 0;
        });

        // Subtitle
        ctx.font = 'normal 32px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.fillText('Hazır. Video oluşturmaya başlamak için butona tıklayın.', canvas.width / 2, canvas.height - 150);

        // Animated play button indicator - tema renginde
        const buttonY = canvas.height - 100;
        const pulseScale = 1 + Math.sin(time * 3) * 0.1;

        ctx.fillStyle = theme.primary + '80'; // 50% opacity
        ctx.beginPath();
        ctx.arc(canvas.width / 2, buttonY, 30 * pulseScale, 0, Math.PI * 2);
        ctx.fill();

        // Play triangle
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2 - 8, buttonY - 10);
        ctx.lineTo(canvas.width / 2 + 8, buttonY);
        ctx.lineTo(canvas.width / 2 - 8, buttonY + 10);
        ctx.closePath();
        ctx.fill();
      }

      function createTimeline() {
        timelineContainer.innerHTML = '';

        videoData.steps.forEach((step, index) => {
          const timelineStep = document.createElement('div');
          timelineStep.className = 'timeline-step';
          timelineStep.id = `timeline-step-${index}`;

          const hasImage = step.codeImage ? '<i class="fas fa-image text-primary ms-2"></i>' : '';
          const hasAudio = step.audioPath ? '<i class="fas fa-volume-up text-success ms-2"></i>' : '';

          timelineStep.innerHTML = `
            <div class="flex-grow-1">
              <strong>Adım ${index + 1}</strong> (${step.duration}s)
              <br>
              <small class="text-muted">${step.text.substring(0, 60)}...</small>
              ${hasImage}
              ${hasAudio}
            </div>
            <div class="text-end">
              <i class="fas fa-clock text-muted"></i>
            </div>
          `;

          timelineContainer.appendChild(timelineStep);
        });
      }

      function setupEventListeners() {
        startBtn.addEventListener('click', startVideoCreation);
        downloadBtn.addEventListener('click', downloadVideo);

        // Tema butonları
        document.getElementById('randomThemeBtn').addEventListener('click', () => {
          changeTheme(); // Random tema
        });

        document.getElementById('currentThemeBtn').addEventListener('click', () => {
          // Tema listesi göster (dropdown-like behavior)
          showThemeSelector();
        });

        document.getElementById('fpsSelect').addEventListener('change', (e) => {
          fps = parseInt(e.target.value);
        });

        document.getElementById('qualitySelect').addEventListener('change', (e) => {
          quality = e.target.value;
        });

        document.getElementById('includeAudio').addEventListener('change', (e) => {
          includeAudio = e.target.checked;
        });

        document.getElementById('includeBackgroundMusic').addEventListener('change', (e) => {
          includeBackgroundMusic = e.target.checked;
          document.getElementById('musicVolumeContainer').style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('musicVolume').addEventListener('input', (e) => {
          musicVolume = e.target.value / 100;
          document.getElementById('musicVolumeValue').textContent = e.target.value;

          // Gerçek zamanlı ses seviyesi güncellemesi
          if (backgroundMusic) {
            backgroundMusic.volume = musicVolume;
          }
          if (backgroundMusicGain) {
            backgroundMusicGain.gain.value = musicVolume;
          }

          console.log('Müzik ses seviyesi güncellendi:', musicVolume);
        });
      }

      function showThemeSelector() {
        // Basit bir alert ile tema seçimi (gelişmiş modal yerine)
        const themeNames = videoThemes.map((theme, index) => `${index + 1}. ${theme.name}`).join('\n');
        const selection = prompt(`Tema seçin (1-${videoThemes.length}):\n\n${themeNames}`);

        if (selection) {
          const themeIndex = parseInt(selection) - 1;
          if (themeIndex >= 0 && themeIndex < videoThemes.length) {
            changeTheme(themeIndex);
          } else {
            alert('Geçersiz tema numarası!');
          }
        }
      }

      async function startVideoCreation() {
        if (isRecording) return;

        // Check if audio durations are loaded
        if (!audioDurationsLoaded) {
          alert('Ses dosyaları henüz yükleniyor, lütfen bekleyin...');
          return;
        }

        try {
          isRecording = true;
          currentStepIndex = 0;
          currentStepTime = 0;
          recordedChunks = [];
          isTransitioning = false;
          transitionTime = 0;

          startBtn.disabled = true;
          startBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Video Oluşturuluyor...';

          // Setup audio context for mixing
          if (includeAudio) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            audioDestination = audioContext.createMediaStreamDestination();

            // Arkaplan müziği başlat
            if (includeBackgroundMusic && backgroundMusic) {
              try {
                console.log('Video kayıt için müzik hazırlanıyor...');

                // AudioBuffer kullanarak müzik yükle (daha güvenilir)
                const response = await fetch(backgroundMusic.src);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                // BufferSource oluştur
                const musicSource = audioContext.createBufferSource();
                musicSource.buffer = audioBuffer;
                musicSource.loop = true;

                // Gain node oluştur
                backgroundMusicGain = audioContext.createGain();
                backgroundMusicGain.gain.value = musicVolume;

                // Bağlantıları yap
                musicSource.connect(backgroundMusicGain);
                backgroundMusicGain.connect(audioDestination);

                // Müziği başlat
                musicSource.start(0);
                console.log('✓ Video kayıt müziği başarıyla başlatıldı (AudioBuffer), ses seviyesi:', musicVolume);

                // Cleanup için referansı sakla
                window.currentMusicSource = musicSource;

              } catch (error) {
                console.error('✗ AudioBuffer müzik başlatılamadı, MediaElement deneniyor:', error);

                // Fallback: MediaElementSource
                try {
                  const musicForRecording = new Audio();
                  musicForRecording.crossOrigin = 'anonymous';
                  musicForRecording.src = backgroundMusic.src;
                  musicForRecording.loop = true;
                  musicForRecording.volume = musicVolume;
                  musicForRecording.preload = 'auto';

                  let musicStarted = false;

                  // AudioContext'e müziği bağla
                  const musicSource = audioContext.createMediaElementSource(musicForRecording);
                  backgroundMusicGain = audioContext.createGain();
                  backgroundMusicGain.gain.value = musicVolume;

                  musicSource.connect(backgroundMusicGain);
                  backgroundMusicGain.connect(audioDestination);

                  // Müziğin yüklenmesini bekle ve başlat
                  const startMusic = async () => {
                    if (musicStarted) return;
                    musicStarted = true;

                    try {
                      musicForRecording.currentTime = 0;
                      await musicForRecording.play();
                      console.log('✓ Fallback müzik başlatıldı, ses seviyesi:', musicVolume);
                    } catch (playError) {
                      console.error('✗ Fallback müzik başlatma hatası:', playError);
                      musicStarted = false;
                    }
                  };

                  musicForRecording.addEventListener('canplaythrough', startMusic);
                  musicForRecording.load();

                  // Cleanup için referansı sakla
                  window.currentMusicElement = musicForRecording;

                } catch (fallbackError) {
                  console.error('✗ Fallback müzik de başlatılamadı:', fallbackError);
                }
              }
            }
          }

          // Setup MediaRecorder with video and audio
          let stream = canvas.captureStream(fps);

          if (includeAudio && audioDestination) {
            // Combine video and audio streams
            const videoTrack = stream.getVideoTracks()[0];
            const audioTrack = audioDestination.stream.getAudioTracks()[0];

            stream = new MediaStream([videoTrack, audioTrack]);
          }

          const options = {
            mimeType: 'video/webm;codecs=vp9',
            videoBitsPerSecond: quality === 'high' ? 8000000 : quality === 'medium' ? 4000000 : 2000000
          };

          mediaRecorder = new MediaRecorder(stream, options);

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              recordedChunks.push(event.data);
            }
          };

          mediaRecorder.onstop = async () => {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);

            // Download butonu
            downloadBtn.style.display = 'block';
            downloadBtn.onclick = () => {
              const a = document.createElement('a');
              a.href = url;
              a.download = `video_${questionId}_${Date.now()}.webm`;
              a.click();
            };

            // YouTube yükleme butonu oluştur
            const youtubeUploadBtn = document.createElement('button');
            youtubeUploadBtn.className = 'btn btn-danger btn-lg w-100 mt-3';
            youtubeUploadBtn.innerHTML = '<i class="fab fa-youtube me-2"></i>YouTube\'a Yükle';
            youtubeUploadBtn.onclick = async function() {
              this.disabled = true;
              this.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Yönlendiriliyor...';

              try {
                // Video verilerini sunucuya kaydet
                await fetch('/api/save-video-data', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    questionId: questionId,
                    videoData: videoData
                  })
                });

                // Video dosyasını sunucuya kaydet
                const formData = new FormData();
                formData.append('video', blob, `video_${questionId}_${Date.now()}.webm`);
                formData.append('questionId', questionId);

                const uploadResponse = await fetch('/api/save-video-for-youtube', {
                  method: 'POST',
                  body: formData
                });

                const uploadResult = await uploadResponse.json();

                if (uploadResult.success) {
                  // YouTube yükleme sayfasına yönlendir
                  window.location.href = `/youtube-upload/${questionId}?videoFile=${uploadResult.videoFile}`;
                } else {
                  throw new Error(uploadResult.error || 'Video kaydedilemedi');
                }
              } catch (error) {
                alert('YouTube yükleme hazırlığında hata: ' + error.message);
                this.disabled = false;
                this.innerHTML = '<i class="fab fa-youtube me-2"></i>YouTube\'a Yükle';
              }
            };

            // YouTube butonunu download butonundan sonra ekle
            downloadBtn.parentNode.insertBefore(youtubeUploadBtn, downloadBtn.nextSibling);

            startBtn.disabled = false;
            startBtn.innerHTML = '<i class="fas fa-play me-2"></i>Yeni Video Oluştur';

            updateProgress(100, 'Tamamlandı!');

            // Cleanup audio
            if (window.currentMusicSource) {
              window.currentMusicSource.stop();
              window.currentMusicSource = null;
            }
            if (window.currentMusicElement) {
              window.currentMusicElement.pause();
              window.currentMusicElement = null;
            }
            if (backgroundMusicGain) {
              backgroundMusicGain.disconnect();
              backgroundMusicGain = null;
            }
            if (audioContext) {
              audioContext.close();
              audioContext = null;
              audioDestination = null;
            }
          };

          mediaRecorder.start();
          startTime = Date.now();

          // Reset timing variables
          videoStartTime = 0;
          lastFrameTime = 0;

          // Start first step audio immediately
          if (includeAudio && videoData.steps.length > 0 && videoData.steps[0].audioPath) {
            setTimeout(() => {
              playStepAudioForRecording(videoData.steps[0].audioPath);
            }, 200);
          }

          // Start animation loop
          animateVideo();

        } catch (error) {
          console.error('Video creation error:', error);
          alert('Video oluşturulurken hata oluştu: ' + error.message);
          isRecording = false;
          startBtn.disabled = false;
          startBtn.innerHTML = '<i class="fas fa-play me-2"></i>Video Oluşturmaya Başla';

          // Cleanup audio on error
          if (window.currentMusicSource) {
            window.currentMusicSource.stop();
            window.currentMusicSource = null;
          }
          if (window.currentMusicElement) {
            window.currentMusicElement.pause();
            window.currentMusicElement = null;
          }
          if (backgroundMusicGain) {
            backgroundMusicGain.disconnect();
            backgroundMusicGain = null;
          }
          if (audioContext) {
            audioContext.close();
            audioContext = null;
            audioDestination = null;
          }
        }
      }

      let lastFrameTime = 0;
      let videoStartTime = 0;
      let stepStartTimes = [];

      function calculateStepStartTimes() {
        stepStartTimes = [];
        let cumulativeTime = 0;

        for (let i = 0; i < videoData.steps.length; i++) {
          stepStartTimes[i] = cumulativeTime;
          const stepDuration = adjustedStepDurations[i] || videoData.steps[i].duration;
          // Her adım bittiğinde 1 saniye bekleme
          cumulativeTime += stepDuration + (i < videoData.steps.length - 1 ? 1 : 0);
        }

        return cumulativeTime; // Total video duration
      }

      function animateVideo(timestamp) {
        if (!isRecording) return;

        // Initialize timing
        if (!videoStartTime) {
          videoStartTime = timestamp;
          lastFrameTime = timestamp;
          calculateStepStartTimes();
        }

        // Calculate elapsed time in seconds
        const totalElapsedTime = (timestamp - videoStartTime) / 1000;

        // Determine which step we should be in based on elapsed time
        let targetStepIndex = 0;
        let stepStartTime = 0;

        for (let i = 0; i < videoData.steps.length; i++) {
          const stepDuration = adjustedStepDurations[i] || videoData.steps[i].duration;
          const stepEndTime = stepStartTimes[i] + stepDuration;

          if (totalElapsedTime >= stepStartTimes[i] && totalElapsedTime < stepEndTime + 1) {
            targetStepIndex = i;
            stepStartTime = stepStartTimes[i];
            break;
          }

          // Check if we're in transition period (1 second after step ends)
          if (totalElapsedTime >= stepEndTime && totalElapsedTime < stepEndTime + 1) {
            targetStepIndex = i;
            stepStartTime = stepStartTimes[i];
            break;
          }
        }

        // Check if video is completed
        const totalVideoTime = calculateStepStartTimes();
        if (totalElapsedTime >= totalVideoTime) {
          if (currentAudio) {
            currentAudio.pause();
            currentAudio = null;
          }
          mediaRecorder.stop();
          isRecording = false;
          return;
        }

        const currentStep = videoData.steps[targetStepIndex];
        const stepElapsedTime = totalElapsedTime - stepStartTime;
        const actualStepDuration = adjustedStepDurations[targetStepIndex] || currentStep.duration;

        // Update step if changed
        if (targetStepIndex !== currentStepIndex) {
          // Mark previous step as completed
          if (currentStepIndex >= 0) {
            const prevTimelineStep = document.getElementById(`timeline-step-${currentStepIndex}`);
            if (prevTimelineStep) {
              prevTimelineStep.classList.add('completed');
            }
          }

          // Stop current audio before changing step
          if (currentAudio) {
            currentAudio.pause();
            currentAudio = null;
          }

          currentStepIndex = targetStepIndex;

          // Play audio for new step (including first step)
          if (includeAudio && currentStep.audioPath) {
            // Small delay to ensure proper audio initialization
            setTimeout(() => {
              playStepAudioForRecording(currentStep.audioPath);
            }, 100);
          }
        }

        // Determine if we're in transition phase (1 second after step ends)
        if (stepElapsedTime >= actualStepDuration) {
          isTransitioning = true;
          transitionTime = stepElapsedTime - actualStepDuration;
          currentStepTime = actualStepDuration;

          // Stop audio during transition
          if (currentAudio && Math.abs(stepElapsedTime - actualStepDuration) < 0.1) {
            currentAudio.pause();
            currentAudio = null;
          }
        } else {
          isTransitioning = false;
          transitionTime = 0;
          currentStepTime = stepElapsedTime;
        }

        // Draw current frame
        drawVideoFrame(currentStep, currentStepTime);

        // Update timeline
        updateTimeline();

        // Update stats
        updateStats();

        // Calculate progress
        const progress = (totalElapsedTime / totalVideoTime) * 100;
        updateProgress(progress, `Adım ${currentStepIndex + 1}/${videoData.steps.length}`);

        // Continue animation with precise timing
        animationId = requestAnimationFrame(animateVideo);
      }

      let currentImage = null;
      let imageCache = {};

      function drawVideoFrame(step, stepTime) {
        const theme = getCurrentTheme();

        // Clear canvas - tema renginde
        ctx.fillStyle = theme.background[0];
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Modern gradient background - tema renklerini kullan
        const gradient = ctx.createRadialGradient(
          canvas.width/2, canvas.height/2, 0,
          canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/2
        );
        gradient.addColorStop(0, theme.background[1]);
        gradient.addColorStop(0.5, theme.background[2]);
        gradient.addColorStop(1, theme.background[0]);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Add subtle pattern overlay
        ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
        for (let i = 0; i < canvas.width; i += 100) {
          for (let j = 0; j < canvas.height; j += 100) {
            ctx.fillRect(i, j, 1, 1);
          }
        }

        // Modern text container with glassmorphism effect
        const textAreaHeight = 300;
        const margin = 40;

        // Glass background
        ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
        ctx.fillRect(margin, margin, canvas.width - margin*2, textAreaHeight);

        // Border glow - tema renginde
        ctx.strokeStyle = theme.primary + '80'; // 50% opacity
        ctx.lineWidth = 2;
        ctx.strokeRect(margin, margin, canvas.width - margin*2, textAreaHeight);

        // Inner glow
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        ctx.strokeRect(margin + 1, margin + 1, canvas.width - margin*2 - 2, textAreaHeight - 2);

        // Calculate word-by-word animation - simplified and more logical
        const text = step.text || '';
        const words = text.split(' ').filter(word => word.length > 0);
        const actualDuration = adjustedStepDurations[currentStepIndex] || step.duration || 5;

        let finalText = '';
        let wordOpacities = [];

        // Simple but effective word timing
        if (step.audioPath && actualDuration > 1) {
          // Audio-based timing: distribute words evenly across audio duration
          const speechStart = 0.1; // Small delay for audio to start
          const speechEnd = actualDuration - 0.3; // Finish slightly before audio ends
          const speechDuration = speechEnd - speechStart;

          if (stepTime >= speechStart) {
            const progress = Math.min(1, (stepTime - speechStart) / speechDuration);

            // Calculate how many words should be fully visible
            const wordIndex = progress * words.length;
            const fullyVisibleWords = Math.floor(wordIndex);
            const partialWordProgress = wordIndex - fullyVisibleWords;

            // Build text with opacity values
            const visibleWords = [];
            wordOpacities = [];

            for (let i = 0; i < words.length; i++) {
              if (i < fullyVisibleWords) {
                // Fully visible words
                visibleWords.push(words[i]);
                wordOpacities.push(1);
              } else if (i === fullyVisibleWords && partialWordProgress > 0) {
                // Currently appearing word with fade-in effect
                visibleWords.push(words[i]);
                wordOpacities.push(Math.min(1, partialWordProgress * 3)); // Faster fade-in
              } else {
                // Not yet visible
                break;
              }
            }

            finalText = visibleWords.join(' ');
          }
        } else {
          // No audio: simple typing effect
          const typingSpeed = 4; // words per second
          const wordIndex = stepTime * typingSpeed;
          const fullyVisibleWords = Math.floor(wordIndex);
          const partialWordProgress = wordIndex - fullyVisibleWords;

          const visibleWords = [];
          wordOpacities = [];

          for (let i = 0; i < words.length; i++) {
            if (i < fullyVisibleWords) {
              visibleWords.push(words[i]);
              wordOpacities.push(1);
            } else if (i === fullyVisibleWords && partialWordProgress > 0) {
              visibleWords.push(words[i]);
              wordOpacities.push(Math.min(1, partialWordProgress * 4));
            } else {
              break;
            }
          }

          finalText = visibleWords.join(' ');
        }

        // Ensure at least something appears after a brief moment
        if (stepTime > 0.2 && finalText.length === 0 && words.length > 0) {
          finalText = words[0];
          wordOpacities = [0.3];
        }

        // Only process if we have visible text
        if (finalText.length > 0) {
          // Modern typography - daha küçük font
          ctx.font = 'bold 42px system-ui, -apple-system, sans-serif';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';

          const displayWords = finalText.split(' ');

          // Text wrapping with opacity support - daha geniş alan
          const maxWidth = canvas.width - (margin + 30)*2;
          let lines = [];
          let currentLine = '';
          let currentLineWords = [];
          let currentLineOpacities = [];
          let wordIndex = 0;

          for (const word of displayWords) {
            const testLine = currentLine + (currentLine ? ' ' : '') + word;
            const metrics = ctx.measureText(testLine);

            if (metrics.width > maxWidth && currentLine) {
              // Finish current line
              lines.push({
                text: currentLine,
                words: [...currentLineWords],
                opacities: [...currentLineOpacities]
              });
              currentLine = word;
              currentLineWords = [word];
              currentLineOpacities = [wordOpacities[wordIndex] || 1];
            } else {
              currentLine = testLine;
              currentLineWords.push(word);
              currentLineOpacities.push(wordOpacities[wordIndex] || 1);
            }
            wordIndex++;
          }

          if (currentLine) {
            lines.push({
              text: currentLine,
              words: currentLineWords,
              opacities: currentLineOpacities
            });
          }

          // Draw text with enhanced spacing and opacity - daha fazla satır
          const lineHeight = 55;
          const textStartY = margin + 30;

          lines.forEach((lineData, lineIndex) => {
            if (lineIndex < 5) {
              const y = textStartY + lineIndex * lineHeight;
              let currentX = margin + 30;

              // Draw each word with its own opacity
              lineData.words.forEach((word, wordIdx) => {
                const opacity = lineData.opacities[wordIdx] || 1;

                // Text shadow for depth
                ctx.fillStyle = `rgba(0, 0, 0, ${0.3 * opacity})`;
                ctx.fillText(word, currentX + 2, y + 2);

                // Main text with opacity
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.fillText(word, currentX, y);

                // Move to next word position
                const wordWidth = ctx.measureText(word + ' ').width;
                currentX += wordWidth;
              });
            }
          });

          // Typing cursor effect - show only if we have more words to display
          const totalWordsShown = displayWords.length;
          const totalWords = words.length;

          if (totalWordsShown < totalWords && finalText.length > 0) {
            const lastLineIndex = Math.min(lines.length - 1, 4);
            const lastLine = lines[lastLineIndex];
            if (lastLine) {
              const cursorX = margin + 30 + ctx.measureText(lastLine.text).width + 10;
              const cursorY = textStartY + lastLineIndex * lineHeight;

              // Blinking cursor
              const blinkSpeed = 800;
              const shouldShowCursor = Math.floor(Date.now() / blinkSpeed) % 2 === 0;

              if (shouldShowCursor) {
                ctx.fillStyle = '#7C3AED';
                ctx.fillRect(cursorX, cursorY + 8, 3, 35);
              }
            }
          }
        }

        // Enhanced image display
        if (step.codeImage) {
          if (imageCache[step.codeImage]) {
            currentImage = imageCache[step.codeImage];
            drawModernImage(currentImage);
          } else {
            loadAndCacheImage(step.codeImage);
          }
        } else if (currentImage) {
          drawModernImage(currentImage);
        }

        // Step indicator (replaces progress bar)
        drawStepIndicator(step, stepTime, actualDuration);
      }

      function drawModernImage(img) {
        if (!img || !img.width || !img.height) return;

        const maxWidth = canvas.width - 120;
        const maxHeight = canvas.height - 420; // 480'den 420'ye (metin alanı büyüdü)

        let drawWidth = img.width;
        let drawHeight = img.height;

        // Scale to fit without padding
        if (drawWidth > maxWidth) {
          drawHeight = (drawHeight * maxWidth) / drawWidth;
          drawWidth = maxWidth;
        }

        if (drawHeight > maxHeight) {
          drawWidth = (drawWidth * maxHeight) / drawHeight;
          drawHeight = maxHeight;
        }

        // Center the image
        const x = (canvas.width - drawWidth) / 2;
        const y = 370; // Metin alanı büyüdüğü için pozisyonu güncelledim

        // Sadece hafif gölge (opsiyonel)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(x + 3, y + 3, drawWidth, drawHeight);

        // Resmi doğrudan çiz (padding yok)
        try {
          ctx.drawImage(img, x, y, drawWidth, drawHeight);
        } catch (error) {
          console.log('Image drawing error:', error);
          // Fallback: draw placeholder
          ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
          ctx.font = '24px system-ui, -apple-system, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Resim yükleniyor...', canvas.width / 2, y + drawHeight / 2);
        }

        // İnce border (opsiyonel)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, drawWidth, drawHeight);
      }

      function drawStepIndicator(step, stepTime, actualDuration) {
        const theme = getCurrentTheme();
        const indicatorWidth = 400;
        const indicatorHeight = 8;
        const x = (canvas.width - indicatorWidth) / 2;
        const y = canvas.height - 100;

        // Background
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(x, y, indicatorWidth, indicatorHeight);

        // Progress - with safety checks
        const safeStepTime = Math.max(0, stepTime || 0);
        const safeDuration = Math.max(0.1, actualDuration || 1);
        const progress = Math.min(1, Math.max(0, safeStepTime / safeDuration));
        const progressWidth = indicatorWidth * progress;

        // Gradient progress bar - tema renklerini kullan
        if (progressWidth > 0) {
          const progressGradient = ctx.createLinearGradient(x, y, x + progressWidth, y);
          progressGradient.addColorStop(0, theme.primary);
          progressGradient.addColorStop(0.5, theme.secondary);
          progressGradient.addColorStop(1, theme.accent);

          ctx.fillStyle = progressGradient;
          ctx.fillRect(x, y, progressWidth, indicatorHeight);
        }

        // Step counter
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.font = 'bold 24px system-ui, -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(
          `${currentStepIndex + 1} / ${videoData.steps.length}`,
          canvas.width / 2,
          y + 40
        );
      }

      function loadAndCacheImage(imagePath) {
        if (imageCache[imagePath]) {
          currentImage = imageCache[imagePath];
          drawModernImage(currentImage);
          return;
        }

        const img = new Image();
        img.onload = () => {
          imageCache[imagePath] = img;
          currentImage = img;
          drawModernImage(img);
        };
        img.src = imagePath;
      }

      function loadAndDrawImage(imagePath) {
        loadAndCacheImage(imagePath);
      }

      function updateTimeline() {
        // Remove all active classes
        document.querySelectorAll('.timeline-step').forEach(step => {
          step.classList.remove('active');
        });

        // Add active class to current step
        const currentTimelineStep = document.getElementById(`timeline-step-${currentStepIndex}`);
        if (currentTimelineStep) {
          currentTimelineStep.classList.add('active');
          currentTimelineStep.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }

      function updateStats() {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;

        // Calculate total and elapsed duration with adjustments
        let totalDuration = 0;
        let elapsedDuration = 0;

        for (let i = 0; i < videoData.steps.length; i++) {
          const stepDuration = adjustedStepDurations[i] || videoData.steps[i].duration;
          totalDuration += stepDuration;

          if (i < currentStepIndex) {
            elapsedDuration += stepDuration;
          }
        }

        elapsedDuration += currentStepTime;
        const remainingDuration = totalDuration - elapsedDuration;

        videoStats.textContent = `Adım: ${currentStepIndex + 1}/${videoData.steps.length} | Süre: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')} | Kalan: ${Math.ceil(remainingDuration)}s | FPS: ${fps}`;

        const currentStep = videoData.steps[currentStepIndex];
        if (currentStep) {
          const actualStepDuration = adjustedStepDurations[currentStepIndex] || currentStep.duration;
          currentStepInfo.textContent = `Adım ${currentStepIndex + 1}: ${currentStep.text.substring(0, 50)}... (${actualStepDuration.toFixed(1)}s)`;

          const stepProg = Math.min(100, (currentStepTime / actualStepDuration) * 100);
          stepProgress.style.width = stepProg + '%';
        }
      }

      function updateProgress(percentage, subtext) {
        const circumference = 2 * Math.PI * 54;
        const offset = circumference - (percentage / 100) * circumference;

        progressRing.style.strokeDashoffset = offset;
        progressText.textContent = Math.round(percentage) + '%';
        progressSubtext.textContent = subtext;
      }

      function playStepAudioForRecording(audioPath) {
        if (!includeAudio || !audioContext || !audioDestination) {
          return;
        }

        // Stop previous audio
        if (currentAudio) {
          currentAudio.pause();
          currentAudio = null;
        }

        try {
          const audio = new Audio(audioPath);
          audio.crossOrigin = 'anonymous';
          currentAudio = audio;

          audio.addEventListener('loadeddata', () => {
            try {
              // Create audio source and connect to destination
              const source = audioContext.createMediaElementSource(audio);
              source.connect(audioDestination);

              // Also connect to default output for monitoring
              source.connect(audioContext.destination);

              audio.play().catch(error => {
                console.log('Audio play error:', error);
              });
            } catch (error) {
              console.log('Audio source creation error:', error);
            }
          });

          audio.addEventListener('error', (error) => {
            console.log('Audio load error:', error);
          });

          // Load the audio
          audio.load();

        } catch (error) {
          console.log('Audio setup error:', error);
        }
      }

      function playStepAudio(audioPath) {
        // For preview mode - simpler audio playback
        if (currentAudio) {
          currentAudio.pause();
          currentAudio = null;
        }

        try {
          currentAudio = new Audio(audioPath);
          currentAudio.play().catch(error => {
            console.log('Preview audio play error:', error);
          });
        } catch (error) {
          console.log('Preview audio setup error:', error);
        }
      }

      let previewIndex = 0;
      let previewTimeout = null;
      let previewAudio = null;

      function previewVideo() {
        if (isRecording) return;

        previewMode = true;
        previewIndex = 0;

        // Update button text
        previewBtn.innerHTML = '<i class="fas fa-stop me-2"></i>Önizlemeyi Durdur';

        // Önizlemede arkaplan müziği başlat
        if (includeBackgroundMusic && backgroundMusic) {
          try {
            backgroundMusic.currentTime = 0;
            backgroundMusic.volume = musicVolume;
            backgroundMusic.play();
            console.log('Önizleme için arkaplan müziği başlatıldı, ses seviyesi:', musicVolume);
          } catch (error) {
            console.error('Önizleme müziği başlatılamadı:', error);
          }
        }

        startPreviewLoop();
      }

      function startPreviewLoop() {
        if (!previewMode || previewIndex >= videoData.steps.length) {
          stopPreview();
          return;
        }

        const step = videoData.steps[previewIndex];

        // Draw frame
        drawVideoFrame(step, 0);

        // Update timeline for preview
        document.querySelectorAll('.timeline-step').forEach((el, index) => {
          el.classList.remove('active', 'completed');
          if (index < previewIndex) el.classList.add('completed');
          else if (index === previewIndex) el.classList.add('active');
        });

        // Update progress
        updateProgress((previewIndex / videoData.steps.length) * 100, `Önizleme: Adım ${previewIndex + 1}/${videoData.steps.length}`);

        // Stop previous audio
        if (previewAudio) {
          previewAudio.pause();
          previewAudio = null;
        }

        // Play audio for preview
        if (step.audioPath) {
          previewAudio = new Audio(step.audioPath);
          previewAudio.play().catch(console.log);
        }

        // Clear previous timeout
        if (previewTimeout) {
          clearTimeout(previewTimeout);
        }

        // Move to next step after duration + 1 second transition
        previewTimeout = setTimeout(() => {
          if (previewMode) {
            previewIndex++;
            startPreviewLoop();
          }
        }, Math.max((step.duration + 1) * 1000, 2000)); // 1 second transition
      }

      function stopPreview() {
        previewMode = false;
        previewBtn.innerHTML = '<i class="fas fa-eye me-2"></i>Önizleme';

        // Clear timeout
        if (previewTimeout) {
          clearTimeout(previewTimeout);
          previewTimeout = null;
        }

        // Stop audio
        if (previewAudio) {
          previewAudio.pause();
          previewAudio = null;
        }

        // Stop background music
        if (backgroundMusic) {
          backgroundMusic.pause();
        }

        // Reset progress and restart welcome screen animation
        updateProgress(0, 'Hazırlanıyor');

        // Reset timeline
        document.querySelectorAll('.timeline-step').forEach(el => {
          el.classList.remove('active', 'completed');
        });

        // Restart welcome screen animation
        animateWelcomeScreen();
      }

      // Update preview button click handler
      previewBtn.addEventListener('click', () => {
        if (previewMode) {
          stopPreview();
        } else {
          previewVideo();
        }
      });

      async function preloadAudioDurations() {
        console.log('Ses dosyası süreleri yükleniyor...');

        for (let i = 0; i < videoData.steps.length; i++) {
          const step = videoData.steps[i];

          if (step.audioPath) {
            try {
              const audioDuration = await getAudioDuration(step.audioPath);
              // Ses süresi baz alınıyor, resim varsa +2 saniye ekleniyor
              let finalDuration = audioDuration;
              if (step.codeImage) {
                finalDuration += 2; // Resim varsa +2 saniye
              }

              adjustedStepDurations[i] = finalDuration;
              console.log(`Adım ${i + 1}: Ses ${audioDuration.toFixed(1)}s${step.codeImage ? ' + Resim 2s' : ''} = ${finalDuration.toFixed(1)}s`);
            } catch (error) {
              console.log(`Adım ${i + 1} ses yüklenemedi, orijinal süre kullanılıyor:`, error);
              // Ses yüklenemezse orijinal süre + resim varsa +2 saniye
              let fallbackDuration = step.duration;
              if (step.codeImage) {
                fallbackDuration += 2;
              }
              adjustedStepDurations[i] = fallbackDuration;
            }
          } else {
            // Ses yoksa orijinal süre + resim varsa +2 saniye
            let fallbackDuration = step.duration;
            if (step.codeImage) {
              fallbackDuration += 2;
            }
            adjustedStepDurations[i] = fallbackDuration;
          }
        }

        audioDurationsLoaded = true;
        console.log('Tüm ses süreleri yüklendi:', adjustedStepDurations);

        // Update UI with new durations
        updateTotalDuration();

        // Arkaplan müziği yükle
        if (includeBackgroundMusic) {
          await loadBackgroundMusic();
        }

        // Debug: Müzik test butonu ekle
        addMusicTestButton();
      }

      async function preloadImages() {
        console.log('Resimler önceden yükleniyor...');

        for (let i = 0; i < videoData.steps.length; i++) {
          const step = videoData.steps[i];

          if (step.codeImage && !imageCache[step.codeImage]) {
            try {
              await loadImageToCache(step.codeImage);
              console.log(`Adım ${i + 1} resmi yüklendi`);
            } catch (error) {
              console.log(`Adım ${i + 1} resmi yüklenemedi:`, error);
            }
          }
        }

        console.log('Tüm resimler yüklendi');
      }

      function loadImageToCache(imagePath) {
        return new Promise((resolve, reject) => {
          if (imageCache[imagePath]) {
            resolve(imageCache[imagePath]);
            return;
          }

          const img = new Image();
          img.onload = () => {
            imageCache[imagePath] = img;
            resolve(img);
          };
          img.onerror = () => {
            reject(new Error('Image loading failed'));
          };
          img.src = imagePath;
        });
      }

      function getAudioDuration(audioPath) {
        return new Promise((resolve, reject) => {
          const audio = new Audio();

          audio.addEventListener('loadedmetadata', () => {
            resolve(audio.duration);
          });

          audio.addEventListener('error', () => {
            reject(new Error('Audio loading failed'));
          });

          audio.src = audioPath;
        });
      }

      function updateTotalDuration() {
        const totalDuration = Object.values(adjustedStepDurations).reduce((sum, duration) => sum + duration, 0);
        const minutes = Math.floor(totalDuration / 60);
        const seconds = Math.floor(totalDuration % 60);

        // Update the duration display if exists
        const durationElement = document.querySelector('#totalDuration');
        if (durationElement) {
          durationElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
      }

      async function loadBackgroundMusic() {
        try {
          console.log('Arkaplan müziği yükleniyor...');

          // Random müzik seç
          const musicFiles = [
            'Otros Hijos - Casa Rosa.mp3',
            'Glaze My Ego - The Soundlings.mp3',
            'Bah Dop Bop - Casa Rosa\'s Tulum Vibes.mp3',
            'Swimming with Gurus - Casa Rosa\'s Tulum Vibes.mp3',
            'Oh Please - Telecasted.mp3',
            'Apollo - Telecasted.mp3'
          ];

          const randomMusic = musicFiles[Math.floor(Math.random() * musicFiles.length)];
          const musicPath = `/musics/${encodeURIComponent(randomMusic)}`;

          console.log('Seçilen müzik:', randomMusic);
          console.log('Müzik yolu:', musicPath);

          // Test: Müzik dosyasının erişilebilir olup olmadığını kontrol et
          try {
            const response = await fetch(musicPath, { method: 'HEAD' });
            if (!response.ok) {
              throw new Error(`Müzik dosyası bulunamadı: ${response.status}`);
            }
            console.log('Müzik dosyası erişilebilir');
          } catch (fetchError) {
            console.error('Müzik dosyası erişim hatası:', fetchError);
            throw fetchError;
          }

          backgroundMusic = new Audio();
          backgroundMusic.crossOrigin = 'anonymous';
          backgroundMusic.preload = 'auto';
          backgroundMusic.loop = true;
          backgroundMusic.volume = musicVolume;

          // Müziğin yüklenmesini bekle
          await new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
              reject(new Error('Müzik yükleme timeout (15s)'));
            }, 15000); // 15 saniye timeout

            const cleanup = () => {
              clearTimeout(timeout);
              backgroundMusic.removeEventListener('canplaythrough', onSuccess);
              backgroundMusic.removeEventListener('loadeddata', onSuccess);
              backgroundMusic.removeEventListener('error', onError);
            };

            const onSuccess = () => {
              cleanup();
              console.log('Müzik başarıyla yüklendi');
              resolve();
            };

            const onError = (e) => {
              cleanup();
              console.error('Müzik yükleme hatası:', e);
              reject(new Error(`Müzik yükleme hatası: ${e.message || 'Bilinmeyen hata'}`));
            };

            backgroundMusic.addEventListener('canplaythrough', onSuccess);
            backgroundMusic.addEventListener('loadeddata', onSuccess);
            backgroundMusic.addEventListener('error', onError);

            // Müzik dosyasını yükle
            backgroundMusic.src = musicPath;
            backgroundMusic.load();
          });

          console.log('Arkaplan müziği başarıyla yüklendi');
        } catch (error) {
          console.error('Arkaplan müziği yüklenirken hata:', error);
          backgroundMusic = null;

          // Kullanıcıya hata mesajı göster
          const errorMsg = `Müzik yükleme hatası: ${error.message}`;
          console.warn(errorMsg);

          // UI'da hata göster (opsiyonel)
          if (document.getElementById('musicError')) {
            document.getElementById('musicError').textContent = errorMsg;
          }
        }
      }

      function addMusicTestButton() {
        // Debug için müzik test butonu ekle
        const testBtn = document.createElement('button');
        testBtn.className = 'btn btn-outline-light w-100 mt-2';
        testBtn.innerHTML = '<i class="fas fa-music me-2"></i>Müzik Test';
        testBtn.onclick = async () => {
          if (backgroundMusic) {
            try {
              if (backgroundMusic.paused) {
                // Ses seviyesini güncelle
                backgroundMusic.volume = musicVolume;
                await backgroundMusic.play();
                testBtn.innerHTML = '<i class="fas fa-pause me-2"></i>Müzik Durdur';
                console.log('Müzik test başlatıldı, ses seviyesi:', musicVolume);
              } else {
                backgroundMusic.pause();
                testBtn.innerHTML = '<i class="fas fa-music me-2"></i>Müzik Test';
                console.log('Müzik test durduruldu');
              }
            } catch (error) {
              console.error('Müzik test hatası:', error);
              alert(`Müzik çalınamadı: ${error.message}`);
            }
          } else {
            console.log('Müzik yüklenmedi, yeniden yüklemeye çalışılıyor...');
            await loadBackgroundMusic();
            if (backgroundMusic) {
              alert('Müzik yüklendi! Tekrar test edin.');
            } else {
              alert('Müzik yüklenemedi! Console\'u kontrol edin.');
            }
          }
        };

        // Download butonundan önce ekle
        downloadBtn.parentNode.insertBefore(testBtn, downloadBtn);
      }

      function downloadVideo() {
        // This will be handled by the MediaRecorder onstop event
      }
    </script>
  </body>
</html>
